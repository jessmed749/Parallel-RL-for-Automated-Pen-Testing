/************************************************************
 * Implementation of vulnerability analysis framework.
 ************************************************************/

#include "VulnerabilityAnalyzer.hpp"
#include "TabularQLearning.hpp"
#include <iostream>
#include <fstream>
#include <random>
#include <algorithm>
#include <cmath>
#include <iomanip>

namespace cyber_rl {

/////////////////////////////////////////////////////////////
// Constructor / Destructor
/////////////////////////////////////////////////////////////

VulnerabilityAnalyzer::VulnerabilityAnalyzer() {
    std::cout << "[VulnerabilityAnalyzer] Initialized\n";
}

VulnerabilityAnalyzer::~VulnerabilityAnalyzer() {
}


/////////////////////////////////////////////////////////////
// Main Experiment Runner
/////////////////////////////////////////////////////////////

std::vector<ExperimentResult> VulnerabilityAnalyzer::run_comparative_analysis() {
    std::cout << "\n========================================\n";
    std::cout << "  COMPARATIVE INFECTION ANALYSIS\n";
    std::cout << "========================================\n\n";
    
    std::vector<ExperimentResult> all_results;
    
    // Compare all infection scenarios
    std::vector<InfectionScenario> scenarios = {
        InfectionScenario::CORE_NODES,
        InfectionScenario::DIST_NODES,
        InfectionScenario::ACCESS_NODES,
        InfectionScenario::RANDOM
    };
    
    for (auto scenario : scenarios) {
        ExperimentConfig config;
        config.scenario = scenario;
        config.topology = NetworkTopology::HIERARCHICAL;
        config.num_initial_infected = 20;
        config.simulation_steps = 200;
        config.num_trials = 10;
        
        std::cout << "Running experiment: " << scenario_to_string(scenario) << "\n";
        
        ExperimentResult result = run_experiment(config);
        all_results.push_back(result);
        
        std::cout << "  Peak infection: " << result.mean_peak_infection * 100.0f 
                  << "% ± " << result.std_peak_infection * 100.0f << "%\n\n";
    }
    
    return all_results;
}


/////////////////////////////////////////////////////////////
// Individual Experiments
/////////////////////////////////////////////////////////////

ExperimentResult VulnerabilityAnalyzer::run_experiment(const ExperimentConfig& config) {
    ExperimentResult result;
    result.config = config;
    
    // Run multiple trials for statistical significance
    for (int trial = 0; trial < config.num_trials; trial++) {
        std::cout << "  Trial " << (trial + 1) << "/" << config.num_trials << "... ";
        
        TrialResult trial_result = run_trial(config, trial);
        result.trials.push_back(trial_result);
        
        std::cout << "Peak: " << (trial_result.peak_infection_rate * 100.0f) << "%\n";
    }
    
    // Compute aggregate statistics
    compute_statistics(result);
    
    return result;
}

TrialResult VulnerabilityAnalyzer::run_trial(const ExperimentConfig& config, int trial_id) {
    // Create environment
    auto env = create_environment(config.topology, config.num_nodes);
    
    // Reset environment
    env->reset();
    
    // Select initial infected nodes based on scenario
    std::vector<int> initial_infected = select_initial_infected(
        config.scenario,
        config.num_initial_infected,
        config.num_nodes,
        config.core_nodes,
        config.dist_nodes
    );
    
    // Manually infect initial nodes
    for (int node : initial_infected) {
        env->infect_node(node);
    }
    
    TrialResult trial_result;
    trial_result.scenario = config.scenario;
    
    // Run simulation and collect measurements
    for (int step = 0; step < config.simulation_steps; step++) {
        // Measure current state
        InfectionMeasurement measurement = measure_infection_state(
            env.get(),
            step,
            config.core_nodes,
            config.dist_nodes
        );
        
        trial_result.timeline.push_back(measurement);
        
        // Propagate infection (no agent actions)
        StepResult sr = env->step(0);  // Dummy action, just propagate
        if (sr.done) {
            break;
        }
    }
    
    // Compute summary statistics
    trial_result.peak_infection_rate = 0.0f;
    trial_result.peak_infection_step = 0;
    trial_result.final_infection_rate = trial_result.timeline.back().infection_rate;
    trial_result.total_infected = 0;
    
    for (size_t i = 0; i < trial_result.timeline.size(); i++) {
        float rate = trial_result.timeline[i].infection_rate;
        if (rate > trial_result.peak_infection_rate) {
            trial_result.peak_infection_rate = rate;
            trial_result.peak_infection_step = static_cast<int>(i);
        }
        trial_result.total_infected += trial_result.timeline[i].infected_count;
    }
    trial_result.total_infected /= trial_result.timeline.size();  // Average
    
    return trial_result;
}


/////////////////////////////////////////////////////////////
// Network Structure Experiments
/////////////////////////////////////////////////////////////

std::vector<ExperimentResult> VulnerabilityAnalyzer::analyze_topology_impact() {
    std::cout << "\n========================================\n";
    std::cout << "  NETWORK TOPOLOGY IMPACT ANALYSIS\n";
    std::cout << "========================================\n\n";
    
    std::vector<ExperimentResult> results;
    
    std::vector<NetworkTopology> topologies = {
        NetworkTopology::HIERARCHICAL,
        NetworkTopology::FLAT_MESH,
        NetworkTopology::RING
    };
    
    for (auto topology : topologies) {
        ExperimentConfig config;
        config.scenario = InfectionScenario::CORE_NODES;
        config.topology = topology;
        config.num_initial_infected = 20;
        config.simulation_steps = 200;
        config.num_trials = 5;
        
        std::cout << "Topology: " << topology_to_string(topology) << "\n";
        
        ExperimentResult result = run_experiment(config);
        results.push_back(result);
    }
    
    return results;
}


/////////////////////////////////////////////////////////////
// Initial Condition Experiments
/////////////////////////////////////////////////////////////

std::vector<ExperimentResult> VulnerabilityAnalyzer::analyze_node_type_criticality() {
    std::cout << "\n========================================\n";
    std::cout << "  NODE TYPE CRITICALITY ANALYSIS\n";
    std::cout << "========================================\n\n";
    
    return run_comparative_analysis();
}


/////////////////////////////////////////////////////////////
// Defense Effectiveness Experiments
/////////////////////////////////////////////////////////////

std::vector<VulnerabilityAnalyzer::DefenseComparison> 
VulnerabilityAnalyzer::analyze_defense_effectiveness(TabularQLearning* trained_agent) {
    std::cout << "\n========================================\n";
    std::cout << "  DEFENSE EFFECTIVENESS ANALYSIS\n";
    std::cout << "  Comparing: No Defense vs RL Agents\n";
    std::cout << "========================================\n\n";
    
    // NOTE: We train scenario-specific agents rather than using pre-trained
    // agent because the pre-trained agent learned on different initial conditions
    (void)trained_agent;  // Not used - we train fresh agents per scenario
    
    std::vector<DefenseComparison> comparisons;
    
    // Test all scenarios
    std::vector<InfectionScenario> scenarios = {
        InfectionScenario::CORE_NODES,
        InfectionScenario::DIST_NODES,
        InfectionScenario::ACCESS_NODES
    };
    
    for (auto scenario : scenarios) {
        std::cout << "Scenario: " << scenario_to_string(scenario) << "\n";
        
        ExperimentConfig config;
        config.scenario = scenario;
        config.topology = NetworkTopology::HIERARCHICAL;
        config.num_initial_infected = 20;
        config.simulation_steps = 200;
        config.num_trials = 5;
        
        // Run WITHOUT defense (baseline)
        std::cout << "  Running baseline (no defense)...\n";
        ExperimentResult no_defense = run_experiment(config);
        
        // CREATE AND TRAIN scenario-specific defense agent
        std::cout << "  Training scenario-specific defense agent...\n";
        auto defense_env = create_environment(config.topology, config.num_nodes);
        
        QLearningConfig rl_config;
        rl_config.learning_rate = 0.01f;
        rl_config.discount_factor = 0.99f;
        rl_config.epsilon = 0.1f;
        rl_config.max_episodes = 500;
        rl_config.num_workers = 4;
        rl_config.replay_capacity = 10000;
        rl_config.min_replay_size = 500;
        rl_config.batch_size = 256;
        
        TabularQLearning scenario_agent(defense_env.get(), rl_config);
        
        // Train agent with THIS specific infection pattern
        std::cout << "    Training for 500 episodes...\n";
        scenario_agent.train(500);
        std::cout << "    Training complete!\n";
        
        // Run WITH trained defense
        std::cout << "  Running with trained defense...\n";
        ExperimentResult with_defense;
        with_defense.config = config;
        
        for (int trial = 0; trial < config.num_trials; trial++) {
            std::cout << "    Trial " << (trial + 1) << "/" << config.num_trials << "... ";
            
            TrialResult trial_result = run_trial_with_defense(config, trial, &scenario_agent);
            with_defense.trials.push_back(trial_result);
            
            std::cout << "Peak: " << (trial_result.peak_infection_rate * 100.0f) << "%\n";
        }
        compute_statistics(with_defense);
        
        // Compute comparison
        DefenseComparison comparison;
        comparison.no_defense = no_defense;
        comparison.with_defense = with_defense;
        comparison.infection_reduction = 
            (no_defense.mean_peak_infection - with_defense.mean_peak_infection) 
            / (no_defense.mean_peak_infection + 0.001f);  // Avoid div by zero
        comparison.defense_effectiveness = 
            1.0f - (with_defense.mean_peak_infection / (no_defense.mean_peak_infection + 0.001f));
        
        comparisons.push_back(comparison);
        
        std::cout << "  Results:\n";
        std::cout << "    No defense:   " << (no_defense.mean_peak_infection * 100.0f) << "%\n";
        std::cout << "    With defense: " << (with_defense.mean_peak_infection * 100.0f) << "%\n";
        std::cout << "    Reduction:    " << (comparison.infection_reduction * 100.0f) << "%\n\n";
    }
    
    return comparisons;
}

TrialResult VulnerabilityAnalyzer::run_trial_with_defense(
    const ExperimentConfig& config,
    int trial_id,
    TabularQLearning* agent)
{
    // Create environment
    auto env = create_environment(config.topology, config.num_nodes);
    
    // Reset environment
    env->reset();
    
    // Select initial infected nodes
    std::vector<int> initial_infected = select_initial_infected(
        config.scenario,
        config.num_initial_infected,
        config.num_nodes,
        config.core_nodes,
        config.dist_nodes
    );
    
    // Manually infect initial nodes
    for (int node : initial_infected) {
        env->infect_node(node);
    }
    
    TrialResult trial_result;
    trial_result.scenario = config.scenario;
    
    std::mt19937 rng(trial_id + 1000);
    
    // Run simulation WITH agent defense
    for (int step = 0; step < config.simulation_steps; step++) {
        // Measure current state
        InfectionMeasurement measurement = measure_infection_state(
            env.get(),
            step,
            config.core_nodes,
            config.dist_nodes
        );
        
        trial_result.timeline.push_back(measurement);
        
        // Agent takes defensive action
        State state = env->get_agent_observation(0);
        int action = agent->get_best_action(state.position);  // Greedy action
        
        // Execute action (defense + propagation)
        StepResult sr = env->step(action);
        if (sr.done) {
            break;
        }
    }
    
    // Compute summary statistics
    trial_result.peak_infection_rate = 0.0f;
    trial_result.peak_infection_step = 0;
    trial_result.final_infection_rate = trial_result.timeline.back().infection_rate;
    trial_result.total_infected = 0;
    
    for (size_t i = 0; i < trial_result.timeline.size(); i++) {
        float rate = trial_result.timeline[i].infection_rate;
        if (rate > trial_result.peak_infection_rate) {
            trial_result.peak_infection_rate = rate;
            trial_result.peak_infection_step = static_cast<int>(i);
        }
        trial_result.total_infected += trial_result.timeline[i].infected_count;
    }
    trial_result.total_infected /= trial_result.timeline.size();
    
    return trial_result;
}


/////////////////////////////////////////////////////////////
// Environment Management
/////////////////////////////////////////////////////////////

std::unique_ptr<CudaNetworkEnv> VulnerabilityAnalyzer::create_environment(
    NetworkTopology topology,
    int num_nodes)
{
    CudaEnvConfig config;
    config.num_nodes = num_nodes;
    config.core_nodes = 100;
    config.dist_nodes = 1000;
    config.max_neighbors = 8;
    config.p_infect = 0.03f;
    config.p_recover = 0.01f;
    config.max_episode_steps = 500;
    
    // Topology would affect graph generation
    // For now, all use hierarchical
    
    return std::make_unique<CudaNetworkEnv>(config);
}


/////////////////////////////////////////////////////////////
// Initial Infection Setup
/////////////////////////////////////////////////////////////

std::vector<int> VulnerabilityAnalyzer::select_initial_infected(
    InfectionScenario scenario,
    int num_infected,
    int num_nodes,
    int core_nodes,
    int dist_nodes)
{
    std::vector<int> infected_nodes;
    std::mt19937 rng(42);
    
    switch (scenario) {
        case InfectionScenario::CORE_NODES: {
            // Infect random core nodes
            std::uniform_int_distribution<int> dist(0, core_nodes - 1);
            for (int i = 0; i < num_infected; i++) {
                infected_nodes.push_back(dist(rng));
            }
            break;
        }
        
        case InfectionScenario::DIST_NODES: {
            // Infect random distribution nodes
            std::uniform_int_distribution<int> dist(core_nodes, core_nodes + dist_nodes - 1);
            for (int i = 0; i < num_infected; i++) {
                infected_nodes.push_back(dist(rng));
            }
            break;
        }
        
        case InfectionScenario::ACCESS_NODES: {
            // Infect random access nodes
            int access_start = core_nodes + dist_nodes;
            std::uniform_int_distribution<int> dist(access_start, num_nodes - 1);
            for (int i = 0; i < num_infected; i++) {
                infected_nodes.push_back(dist(rng));
            }
            break;
        }
        
        case InfectionScenario::RANDOM: {
            // Infect completely random nodes
            std::uniform_int_distribution<int> dist(0, num_nodes - 1);
            for (int i = 0; i < num_infected; i++) {
                infected_nodes.push_back(dist(rng));
            }
            break;
        }
        
        case InfectionScenario::MIXED: {
            // Mix across all layers
            int per_layer = num_infected / 3;
            std::uniform_int_distribution<int> core_dist(0, core_nodes - 1);
            std::uniform_int_distribution<int> dist_dist(core_nodes, core_nodes + dist_nodes - 1);
            std::uniform_int_distribution<int> access_dist(core_nodes + dist_nodes, num_nodes - 1);
            
            for (int i = 0; i < per_layer; i++) {
                infected_nodes.push_back(core_dist(rng));
                infected_nodes.push_back(dist_dist(rng));
                infected_nodes.push_back(access_dist(rng));
            }
            break;
        }
    }
    
    return infected_nodes;
}


/////////////////////////////////////////////////////////////
// Measurement Collection
/////////////////////////////////////////////////////////////

InfectionMeasurement VulnerabilityAnalyzer::measure_infection_state(
    CudaNetworkEnv* env,
    int timestep,
    int core_nodes,
    int dist_nodes)
{
    InfectionMeasurement measurement;
    measurement.timestep = timestep;
    
    // Get infection counts from environment
    int total_infected = env->get_infected_count();
    float infection_rate = env->get_infection_ratio();
    
    measurement.infected_count = total_infected;
    measurement.infection_rate = infection_rate;
    
    // Use actual network size instead of hard-coded 50000
    int total_nodes = env->get_num_nodes();
    measurement.susceptible_count = total_nodes - total_infected;
    if (measurement.susceptible_count < 0) {
        measurement.susceptible_count = 0;
    }
    measurement.recovered_count = 0;
    
    // (Optional) per-layer breakdowns could be filled in later
    measurement.core_infected = 0;
    measurement.dist_infected = 0;
    measurement.access_infected = 0;
    
    return measurement;
}


/////////////////////////////////////////////////////////////
// Statistical Analysis
/////////////////////////////////////////////////////////////

void VulnerabilityAnalyzer::compute_statistics(ExperimentResult& result) {
    std::vector<float> peak_infections;
    std::vector<float> final_infections;
    
    for (const auto& trial : result.trials) {
        peak_infections.push_back(trial.peak_infection_rate);
        final_infections.push_back(trial.final_infection_rate);
    }
    
    compute_mean_std(peak_infections, result.mean_peak_infection, result.std_peak_infection);
    compute_mean_std(final_infections, result.mean_final_infection, result.std_final_infection);
}

void VulnerabilityAnalyzer::compute_mean_std(
    const std::vector<float>& values,
    float& mean,
    float& std)
{
    if (values.empty()) {
        mean = 0.0f;
        std = 0.0f;
        return;
    }
    
    // Compute mean
    float sum = 0.0f;
    for (float v : values) {
        sum += v;
    }
    mean = sum / values.size();
    
    // Compute standard deviation
    float var_sum = 0.0f;
    for (float v : values) {
        float diff = v - mean;
        var_sum += diff * diff;
    }
    std = std::sqrt(var_sum / values.size());
}


/////////////////////////////////////////////////////////////
// Results Export
/////////////////////////////////////////////////////////////

void VulnerabilityAnalyzer::export_to_csv(
    const std::vector<ExperimentResult>& results,
    const std::string& filename)
{
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Failed to open " << filename << "\n";
        return;
    }
    
    // Write header
    file << "Scenario,Trial,Timestep,Infected,InfectionRate,CoreInfected,DistInfected,AccessInfected\n";
    
    // Write data
    for (const auto& result : results) {
        std::string scenario_name = scenario_to_string(result.config.scenario);
        
        for (size_t trial_idx = 0; trial_idx < result.trials.size(); trial_idx++) {
            const auto& trial = result.trials[trial_idx];
            
            for (const auto& measurement : trial.timeline) {
                file << scenario_name << ","
                     << trial_idx << ","
                     << measurement.timestep << ","
                     << measurement.infected_count << ","
                     << measurement.infection_rate << ","
                     << measurement.core_infected << ","
                     << measurement.dist_infected << ","
                     << measurement.access_infected << "\n";
            }
        }
    }
    
    file.close();
    std::cout << "[VulnerabilityAnalyzer] Exported to " << filename << "\n";
}

void VulnerabilityAnalyzer::export_to_json(
    const std::vector<ExperimentResult>& results,
    const std::string& filename)
{
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Failed to open " << filename << "\n";
        return;
    }
    
    file << "{\n";
    file << "  \"experiments\": [\n";
    
    for (size_t i = 0; i < results.size(); i++) {
        const auto& result = results[i];
        
        file << "    {\n";
        file << "      \"scenario\": \"" << scenario_to_string(result.config.scenario) << "\",\n";
        file << "      \"mean_peak_infection\": " << result.mean_peak_infection << ",\n";
        file << "      \"std_peak_infection\": " << result.std_peak_infection << ",\n";
        file << "      \"mean_final_infection\": " << result.mean_final_infection << ",\n";
        file << "      \"std_final_infection\": " << result.std_final_infection << ",\n";
        file << "      \"num_trials\": " << result.trials.size() << "\n";
        file << "    }";
        
        if (i < results.size() - 1) file << ",";
        file << "\n";
    }
    
    file << "  ]\n";
    file << "}\n";
    
    file.close();
    std::cout << "[VulnerabilityAnalyzer] Exported to " << filename << "\n";
}

void VulnerabilityAnalyzer::print_results(const std::vector<ExperimentResult>& results) {
    std::cout << "\n========================================\n";
    std::cout << "  EXPERIMENT RESULTS SUMMARY\n";
    std::cout << "========================================\n\n";
    
    for (const auto& result : results) {
        std::cout << "Scenario: " << scenario_to_string(result.config.scenario) << "\n";
        std::cout << "  Peak infection: " << std::fixed << std::setprecision(1)
                  << (result.mean_peak_infection * 100.0f) << "% ± "
                  << (result.std_peak_infection * 100.0f) << "%\n";
        std::cout << "  Final infection: " << (result.mean_final_infection * 100.0f) << "% ± "
                  << (result.std_final_infection * 100.0f) << "%\n";
        std::cout << "  Trials: " << result.trials.size() << "\n\n";
    }
    
    // Print key finding
    if (results.size() >= 3) {
        float core_peak = results[0].mean_peak_infection;
        float access_peak = results[2].mean_peak_infection;
        float ratio = core_peak / (access_peak + 0.001f);  // Avoid div by zero
        
        std::cout << "KEY FINDING:\n";
        std::cout << "  Compromising core nodes leads to " << std::fixed << std::setprecision(1)
                  << ratio << "x more infections than access nodes\n";
        std::cout << "  (" << (core_peak * 100.0f) << "% vs " 
                  << (access_peak * 100.0f) << "% peak rate)\n\n";
    }
}

void VulnerabilityAnalyzer::print_defense_comparison(
    const std::vector<DefenseComparison>& comparisons)
{
    std::cout << "\n========================================\n";
    std::cout << "  DEFENSE EFFECTIVENESS SUMMARY\n";
    std::cout << "========================================\n\n";
    
    float total_reduction = 0.0f;
    
    for (const auto& comp : comparisons) {
        std::string scenario = scenario_to_string(comp.no_defense.config.scenario);
        
        std::cout << "Scenario: " << scenario << "\n";
        std::cout << "  No defense:   " << std::fixed << std::setprecision(1)
                  << (comp.no_defense.mean_peak_infection * 100.0f) << "% peak infection\n";
        std::cout << "  With defense: " 
                  << (comp.with_defense.mean_peak_infection * 100.0f) << "% peak infection\n";
        std::cout << "  Reduction:    " 
                  << (comp.infection_reduction * 100.0f) << "%\n";
        std::cout << "  Effectiveness: " 
                  << (comp.defense_effectiveness * 100.0f) << "%\n\n";
        
        total_reduction += comp.infection_reduction;
    }
    
    float avg_reduction = total_reduction / comparisons.size();
    
    std::cout << "========================================\n";
    std::cout << "KEY FINDING:\n";
    std::cout << "  RL-trained agents reduce infections by\n";
    std::cout << "  " << std::fixed << std::setprecision(1) 
              << (avg_reduction * 100.0f) << "% on average\n";
    std::cout << "========================================\n\n";
}


/////////////////////////////////////////////////////////////
// Utility Functions
/////////////////////////////////////////////////////////////

std::string scenario_to_string(InfectionScenario scenario) {
    switch (scenario) {
        case InfectionScenario::CORE_NODES: return "CORE_NODES";
        case InfectionScenario::DIST_NODES: return "DIST_NODES";
        case InfectionScenario::ACCESS_NODES: return "ACCESS_NODES";
        case InfectionScenario::MIXED: return "MIXED";
        case InfectionScenario::RANDOM: return "RANDOM";
        default: return "UNKNOWN";
    }
}

std::string topology_to_string(NetworkTopology topology) {
    switch (topology) {
        case NetworkTopology::HIERARCHICAL: return "HIERARCHICAL";
        case NetworkTopology::FLAT_MESH: return "FLAT_MESH";
        case NetworkTopology::RING: return "RING";
        case NetworkTopology::STAR: return "STAR";
        default: return "UNKNOWN";
    }
}

} // namespace cyber_rl