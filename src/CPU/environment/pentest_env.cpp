#include "pentest_env.h"
#include <stdexcept>

// Constants
const int NUM_NODES = 5;
const int MAX_STEPS = 20;

// Constructor-> init RNG, call reset()
PentestEnv::PentestEnv(int seed) : rng(seed), current_state(0) {
    reset();
}

// reset(): set init state
void PentestEnv::reset() {
    current_state = 0b00001;  // Only first node (bit 0) is set
}

// step(): Execute action and return reward
int PentestEnv::step(Action action) {
    // Increment step counter 

    // Determine if action is valid
    if (!is_valid_action(action)) {
        // Invalid action penalty
        return -10;
    }

    int reward = 0;
    bool success = false;
    int current_node = get_current_node();
    int target_node = current_node;

    switch (action) {
        case SCAN_NEXT:
            target_node = current_node + 1;
            if (target_node < NUM_NODES) {
                // Scan always succeeds if valid
                success = true;
                reward = 1;  // Small reward for scanning
                set_current_node(target_node);
            }
            break;

        case SCAN_PREV:
            target_node = current_node - 1;
            if (target_node >= 0) {
                // Scan always succeeds if valid
                success = true;
                reward = 1;  // Small reward for scanning
                set_current_node(target_node);
            }
            break;

        case EXPLOIT_NEXT:
            target_node = current_node + 1;
            if (target_node < NUM_NODES) {
                // Exploit has success probability
                std::uniform_real_distribution<double> dist(0.0, 1.0);
                double rand_val = dist(rng);

                if (rand_val < 0.7) {  // 70% success rate
                    success = true;

                    // Check if node was already compromised
                    if (!is_node_compromised(target_node)) {
                        set_node_compromised(target_node);
                        reward = 10;  // Big reward for new compromise
                    } else {
                        reward = 1;  // Small reward for redundant exploit
                    }

                    set_current_node(target_node);
                } else {
                    reward = -5;  // Penalty for failed exploit
                }
            }
            break;

        case EXPLOIT_PREV:
            target_node = current_node - 1;
            if (target_node >= 0) {
                // Exploit has success probability
                std::uniform_real_distribution<double> dist(0.0, 1.0);
                double rand_val = dist(rng);

                if (rand_val < 0.7) {  // 70% success rate
                    success = true;

                    // Check if node was already compromised
                    if (!is_node_compromised(target_node)) {
                        set_node_compromised(target_node);
                        reward = 10;  // Big reward for new compromise
                    } else {
                        reward = 1;  // Small reward for redundant exploit
                    }

                    set_current_node(target_node);
                } else {
                    reward = -5;  // Penalty for failed exploit
                }
            }
            break;

        default:
            reward = -10;  // Invalid action
            break;
    }


    // Check if done
    if (is_episode_done()) {
        reward += 50;  // Bonus for completing episode
    }

    // Build and return result
    return reward;
}

// Get current node from state
int PentestEnv::get_current_node() const {
    // Extract current node from upper bits of state
    return (current_state >> 8) & 0xFF;
}

// Set current node in state
void PentestEnv::set_current_node(int node) {
    // Clear upper bits and set new node
    current_state = (current_state & 0xFF) | (node << 8);
}

// Check if a node is compromised
bool PentestEnv::is_node_compromised(int node) const {
    return (current_state & (1 << node)) != 0;
}

// Mark a node as compromised
void PentestEnv::set_node_compromised(int node) {
    current_state |= (1 << node);
}

// Check if action is valid
bool PentestEnv::is_valid_action(Action action) const {
    int current_node = get_current_node();

    switch (action) {
        case SCAN_NEXT:
        case EXPLOIT_NEXT:
            return current_node < NUM_NODES - 1;

        case SCAN_PREV:
        case EXPLOIT_PREV:
            return current_node > 0;

        default:
            return false;
    }
}

// Calculate reward (alt  if needed)
double PentestEnv::calculate_reward(Action action, bool success) const {
    if (!success) {
        return -5.0;  // Penalty for failure
    }

    switch (action) {
        case SCAN_NEXT:
        case SCAN_PREV:
            return 1.0;  // Small reward for scanning

        case EXPLOIT_NEXT:
        case EXPLOIT_PREV:
            return 10.0;  // Large reward for successful exploit

        default:
            return -10.0;  // Invalid action
    }
}

//  Check if episode is done
bool PentestEnv::is_episode_done() const {
    // done when all nodes are compromised
    int all_compromised_mask = (1 << NUM_NODES) - 1;
    return (current_state & all_compromised_mask) == all_compromised_mask;
}

// Get state representation
std::array<int, 5> PentestEnv::get_observation() const {
    std::array<int, 5> obs;
    for (int i = 0; i < NUM_NODES; i++) {
        obs[i] = is_node_compromised(i) ? 1 : 0;
    }
    return obs;
}

// Get observation space size
int PentestEnv::get_observation_space_size() const {
    return NUM_NODES;
}

// Get action space size
int PentestEnv::get_action_space_size() const {
    return 4;  // SCAN_NEXT, EXPLOIT_NEXT, SCAN_PREV, EXPLOIT_PREV
}